{"meta":{"title":"Personal Blog","subtitle":"随性写博客，一生爱自由","description":"","author":"沈春龙","url":"http://yoursite.com","root":"/"},"pages":[{"title":"标签","date":"2020-01-12T01:39:04.000Z","updated":"2020-01-21T10:58:39.308Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-01-12T01:46:26.000Z","updated":"2020-01-21T10:58:00.057Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"IO流","slug":"IO流","date":"2020-02-02T13:51:26.000Z","updated":"2020-02-02T16:18:40.062Z","comments":true,"path":"2020/02/02/IO流/","link":"","permalink":"http://yoursite.com/2020/02/02/IO%E6%B5%81/","excerpt":"前言最近系统的学习了一下JAVA里面的IO流，IO流是Java的重要特性，通过IO流可以很好的支持网络传输，这就是为什么说Java是为互联网而生的。","text":"前言最近系统的学习了一下JAVA里面的IO流，IO流是Java的重要特性，通过IO流可以很好的支持网络传输，这就是为什么说Java是为互联网而生的。 一，File类要想了解IO流首先的学习file类： 1.file类定义 java.io.file类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。 File类是“文件和目录路径名的抽象表示”，而不是指文件内容（IO）。 2.file类的构造方法与常用方法 构造方法 File(String parent, String child)从父路径名字符串和子路径名字符串创建新的 File实例。 File(URI uri)通过将给定的 file: URI转换为抽象路径名来创建新的 File实例。 File(String pathname)通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 Modifier and Type Method and Description boolean canRead()测试应用程序是否可以读取由此抽象路径名表示的文件。 boolean canWrite()测试应用程序是否可以修改由此抽象路径名表示的文件。 boolean createNewFile()当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。 boolean delete()删除由此抽象路径名表示的文件或目录。 boolean exists()测试此抽象路径名表示的文件或目录是否存在。 File getAbsoluteFile()返回此抽象路径名的绝对形式。 String getName()返回由此抽象路径名表示的文件或目录的名称。 boolean isDirectory()测试此抽象路径名表示的文件是否为目录。 boolean isFile()测试此抽象路径名表示的文件是否为普通文件。 boolean isHidden()测试此抽象路径名命名的文件是否为隐藏文件。 long lastModified()返回此抽象路径名表示的文件上次修改的时间。 long length()返回由此抽象路径名表示的文件的长度。 boolean mkdir()创建由此抽象路径名命名的目录。 boolean mkdirs()创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。 String[] list()返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录。 二、IO流2.1流的概念： 流是一组有顺序的,有起点和终点的字节集合,是对数据传输的总称或抽象。即数据在两设备间的传输称为流。流的本质是数据传输,根据数据传输特性将流抽象为各种类,方便更直观的进行数据操作。 2.2IO流的分类: 根据处理数据类型的不同分为:字节流（二进制，可以处理一切文件，文本，音频等）和字符流（文本文件，只能是纯文本，像txt）,其结构如下图。 根据数据流向不同分为:输入流和输出流。 三、字节流四、字符流","categories":[],"tags":[]},{"title":"20184350135 沈春龙 作业六","slug":"20184350135 沈春龙 作业六","date":"2020-02-01T11:41:49.146Z","updated":"2020-02-01T11:45:06.017Z","comments":true,"path":"2020/02/01/20184350135 沈春龙 作业六/","link":"","permalink":"http://yoursite.com/2020/02/01/20184350135%20%E6%B2%88%E6%98%A5%E9%BE%99%20%E4%BD%9C%E4%B8%9A%E5%85%AD/","excerpt":"","text":"123456789101112131415161718192021222324252627package Collection;import java.io.IOException;import java.nio.charset.Charset;import java.nio.file.Files;import java.nio.file.Paths;import java.util.ArrayList;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class WordCount3 &#123; public static void main(String[] args) throws IOException &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(Files.lines(Paths.get(\"D://JAVAcode//老九学堂\\\\src//Collection/Stop_Words.txt\")) .flatMap(x-&gt; Stream.of(x.replaceAll(\"[^a-zA-Z']\", \" \").replaceAll(\" +\",\" \").split(\" \"))) .collect(Collectors.toList())); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(Files.lines(Paths.get(\"D://JAVAcode//老九学堂\\\\src//Collection/work.txt\")) .flatMap(x-&gt; Stream.of(x.replaceAll(\"[^a-zA-Z']\", \" \").replaceAll(\" +\",\" \").split(\" \"))) .filter(x-&gt;!list.contains(x)) .collect(Collectors.toList())); Files.write(Paths.get(\"D://JAVAcode//老九学堂\\\\\\\\src//Collection/Words.txt\"), list2, Charset.forName(\"utf-8\")); &#125;&#125;","categories":[],"tags":[]},{"title":"正则表达式","slug":"正则表达式","date":"2020-02-01T07:26:35.000Z","updated":"2020-02-01T07:49:07.245Z","comments":true,"path":"2020/02/01/正则表达式/","link":"","permalink":"http://yoursite.com/2020/02/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"流式编程","slug":"流式编程","date":"2020-01-30T03:40:27.778Z","updated":"2020-02-01T07:48:36.249Z","comments":true,"path":"2020/01/30/流式编程/","link":"","permalink":"http://yoursite.com/2020/01/30/%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"title: 流式编程date: 2020-01-30 11:40:27tags:","categories":[],"tags":[]},{"title":"20184350135 沈春龙 作业四","slug":"20184350135 沈春龙 作业四","date":"2020-01-29T10:57:22.259Z","updated":"2020-01-29T11:19:36.143Z","comments":true,"path":"2020/01/29/20184350135 沈春龙 作业四/","link":"","permalink":"http://yoursite.com/2020/01/29/20184350135%20%E6%B2%88%E6%98%A5%E9%BE%99%20%E4%BD%9C%E4%B8%9A%E5%9B%9B/","excerpt":"","text":"第一题： 1234567891011package Stream_API;import java.util.stream.Collectors;import java.util.stream.Stream;public class CharCout &#123; public static void mian(String[] args) &#123; String str = \"Your。future：depends#@￥on your dreams,so go to sleep.\"; Stream.of(str.replaceAll(\"[^a-zA-Z]\", \"\").split(\"\")).collect(Collectors.groupingBy(x-&gt; x)).forEach((a,b)-&gt; System.out.println(a+\"=\"+b.size())); &#125;&#125; 第二题： 1234567891011121314151617package Collection;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.util.stream.Stream;public class WordCount2 &#123; public static void main(String[] args) throws Exception&#123; InputStream inputStream = WordCount.class.getResourceAsStream(\"work.txt\"); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); br.lines().flatMap(x-&gt; Stream.of(x.replaceAll(\"\\\\pP\", \" \").split(\" \"))).map(String::toLowerCase).filter(x-&gt;x!=\"a\"||x!=\"the\").distinct().sorted().forEach(System.out::println); &#125;&#125;","categories":[],"tags":[]},{"title":"函数式编程","slug":"函数式编程","date":"2020-01-26T09:34:40.000Z","updated":"2020-01-27T16:39:06.430Z","comments":true,"path":"2020/01/26/函数式编程/","link":"","permalink":"http://yoursite.com/2020/01/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"介绍 函数式编程是一种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。简单说，”函数式编程”是一种“编程范式”（programming paradigm），也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。","text":"介绍 函数式编程是一种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。简单说，”函数式编程”是一种“编程范式”（programming paradigm），也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 (看完下面这个视频给你一个大概的印象) 咱们先不管哪些啥定义的，先了解函数式编程到底怎么用呢？下面给出一个面试题： 统计文本中的单词个数，请用尽可能简练的代码使用Java语言来实现，形式如下： 一般我们的传统思维就是写出下面这种编程风格 12345678910111213141516171819202122232425public class WordCount &#123; public static void main(String[] args) throws Exception&#123; InputStream inputStream = WordCount.class.getResourceAsStream(\"work.txt\"); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String line=\"\"; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); while((line=br.readLine()) != null) &#123; String[] split = line.split(\" \"); initResult(map, split[0]); initResult(map, split[1]); &#125; System.out.println(map); &#125; private static void initResult(Map&lt;String, Integer&gt; result, String key) &#123; Integer value = 1; if(result.containsKey(key)) &#123; value = result.get(key) + 1; &#125; result.put(key,value); &#125;&#125;","categories":[],"tags":[]},{"title":"Java学习————作业三（寒假）","slug":"Java学习———作业三（寒假）","date":"2020-01-18T11:03:37.000Z","updated":"2020-01-26T11:21:14.980Z","comments":true,"path":"2020/01/18/Java学习———作业三（寒假）/","link":"","permalink":"http://yoursite.com/2020/01/18/Java%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E2%80%94%E4%BD%9C%E4%B8%9A%E4%B8%89%EF%BC%88%E5%AF%92%E5%81%87%EF%BC%89/","excerpt":"概述set,list,queue集合的使用","text":"概述set,list,queue集合的使用 第一题： Queue通常用于操作存储一组队列方式的对象信息 ，一般存储方式为先进先出。 其几种特殊方法： Booleanoffer（element） 向队列中插入一个元素（类似add方法）。 E poll() 获取并删除队列头元素。为空则返回null。 E remove() 获取并删除队列头元素，为空则返回异常。 E peek() 获取但不删除列头元素，如果队列为空返回null。 E element() 获取但不删除列头元素，如果队列为空抛出异常。 其主要子类： DelayQueue PriorityQueue 优先队列，最小值拥有优先级最先删除。 ArrayQueue 双端队列，集合容量可动态扩展 LinkedQueue LinkedList 第二题123456789101112131415161718192021222324252627282930313233package Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class test2 &#123; public static void main(String[] args) &#123; int sum = 50; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); //生成五十个不重复随机数存储到set集合 while(set.size()&lt;=sum) &#123; int random = (int)(Math.random()*(100)); set.add(random); &#125; //使用迭代器遍历输出 Iterator&lt;Integer&gt; it1 = set.iterator(); while(it1.hasNext()) &#123; System.out.print(it1.next() + \",\"); &#125; System.out.println(); //三次循环删除最大值 for(int i=0; i&lt;3; i++) &#123; int max = Collections.max(set); set.remove(max); &#125; //使用foreach循环输出 for(Integer i : set) &#123; System.out.print(i+\",\"); &#125; &#125;&#125; 运行结果： 第三题123456789101112131415161718192021222324252627282930313233package Collection;import java.util.HashMap;import java.util.Map;public class test3 &#123; public static void CharNum(String str) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;str.length();i++) &#123; char ch = str.charAt(i); if(ch&gt;='a'&amp;&amp;ch&lt;='z'||ch&gt;='A'&amp;&amp;ch&lt;='Z') &#123; //判断map集合中是否含有字母，如果有次数加1一，没有就初始化为1。 if(map.containsKey(ch)) &#123; Integer num = map.get(ch); map.put(ch, ++num); &#125;else &#123; map.put(ch,1); &#125; &#125; &#125; //使用foreach循环输出 for (Character key : map.keySet()) &#123; Integer value = map.get(key); System.out.println(key+\"出现了 \"+value+\"次\"); &#125; &#125; public static void main(String[] args) &#123; String str = \"Your。future：depends#@￥on your dreams,so go to sleep.\"; CharNum(str); &#125;&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"-Collection框架","slug":"Collection框架","permalink":"http://yoursite.com/tags/Collection%E6%A1%86%E6%9E%B6/"}]},{"title":"Collection框架","slug":"Collection框架","date":"2020-01-17T12:12:45.000Z","updated":"2020-01-25T06:34:03.108Z","comments":true,"path":"2020/01/17/Collection框架/","link":"","permalink":"http://yoursite.com/2020/01/17/Collection%E6%A1%86%E6%9E%B6/","excerpt":"前言 有了数组为什么还需要集合框架? 为了适应实际开发过程中,保存动态变化的数据集合,而数组一旦定义,长度将不能变化,于是就有我么动态增长的集合框架.","text":"前言 有了数组为什么还需要集合框架? 为了适应实际开发过程中,保存动态变化的数据集合,而数组一旦定义,长度将不能变化,于是就有我么动态增长的集合框架. 集合框架介绍 一组存储对象的容器（动态） Collection接口：存储另一个元素的集合 Collections：操作集合的工具类 Map接口（图）：存储键/值对 注意：集合框架中所有的具体类都实现了Cloneable和Serializabel接口，即他们的实例都是可复制且可序列化的。 Collection接口： Collection接口： 方法 描述 boolean add(E e); 向集合中添加元素 int size(); 返回集合中的元素个数 void clear(); 删除集合中的所有元素 boolean remove(Object o); 从集合删除元素o boolean removeAll(Collection&lt;?&gt; c); 从集合中删除集合c中的所有元素 boolean retainAll(Collection&lt;?&gt; c); 保留c和该集合都有的元素（交集） boolean addAll(Collection&lt;? extends E&gt; c); 将集合c中所有元素添加到当前这个集合 boolean contains(Object o); 如果该集合包含对象o,返回true boolean containsAll(Collection&lt;?&gt; c); 如果该集合中包含集合c中所有元素，返回true boolean isEmpty(); 如果集合不包含任何元素，则返回true Iterator iterator(); 返回该集合中元素所有的迭代器 Object[] toArray(); 返回该集合元素构成的Object数组 三种主要子接口 Set(规则类)：存储一组不重复的元素 List(线性表)：存储一个有序集合 Queue(队列)：存储用先进先出方式处理的对象 注意：Collection是集合最高接口，但是直接使用Collection接口会造成操作意义不明确，所以在实际开发中不直接使用Collection接口 List接口 具有索引的List接口 方法 描述 public void add(int index, E element) 在指定位置增加元素 public boolean addAll(int index, E element) 在指定位置增加一组元素 E get(int index) 返回指定位置元素 public int indexOf(Object o) 查找指定元素的位置 public int lastindex Of(Object o) 从后往前查找指定元素的位置 public Listlterator listlterator() 获得List迭代器对象(可以在指定位置向前或向后访问，可以修改集合中的元素) public E remove(int index) 删除指定位置的元素 public List subList(int fromlndex, int tolndex) 取出集合中的子集合 public E set(int index, E element) 替换指定位置的元素 List接口下的三个实现类 ArrayList –数组线性表，是一个大小可变的数组，在内存中分配连续的空间，遍历元素和随机访问元素的效率比较高。 LinkedList –链表，采用链表存储方式，提供从线性表两端提取、插入和删除元素的方法，插入、删除元素效率比较高。 List接口扩展了Collection接口的方法，这些方法使用起来比父接口更加方便，要使用List接口，需要对List接口的实现类实例化 Set接口 用来操作存储一组唯一,无序的对象 v Set接口下的三个实现类 HashSet – 用来存储互不相同的任何元素 LinkedHashSet – 使用链表扩展实现HashSet类,支持对元素的排序 TreeSet – 可以确保所有元素是有序的 Queue接口 通常用于操作一组队列方式的对象信息(一般存储方式为先进先出) 方法 描述 boolean offer(element) 向队列中插入一个元素(类型add方法) E poll() 获取并删除队列头元素,如果队列为空返回null E remove() 获取并删除队列头元素,如果队列为空抛出异常 E peek() 获取但不删除列头元素,如果队列为空返回null E element() 获取但不删除列头头元素,如果队列为空抛出异常 主要实现子类 PriorityQueue 优先队列，最小值拥有优先级最先删除。 ArrayQueue 双端队列，集合容量可动态扩展 注意: 1.Deque支持在两端插入和删除元素,是双端队列的简称(double-ended queue),支持从两端操作队列的元素 2.定义的方法:addFirst(e), removeFirst(e), addLast(e), removeLast(e), getFirst()/getLast() Map接口 以键-值存储元素的容器，根据关键字(key)找到对应的数据 方法 描述 V put(key,value) 将一个键/值映射放入图中 V get(key) 根据键获取对应的value值 Set keySet() 返回包含键的规则集 Collection values() 返回包含值得集合 boolean containsKey(key) 返回图中是否包含键值key Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 返回一个图中包含条目的规则集 int size() 返回途中的键值对个数 V remove(key) 删除指定键对应的条目 其主要子类及其用途 子类 描述 HashMap 查询、插入和删除比较高效 LinkedHashMap 支持元素的排序 TreeMap 遍历有序的键值时非常高效、 Properties 一般用于操作属性文件 Map三种遍历方式 通过Map.keySet遍历key,通过key取出对应的value（比较常用，需要二次取值） 123for(String key : treeMap.keySet())&#123; System.out.println(key + \"--\" + treeMap.get(key));&#125; 通过Map.entrySet使用迭代器遍历key和value（不常用，代码复杂） 123456Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = treeMap.entrySet();Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySetIt = entrySet.iterator();while(entrySetIt.hasNext())&#123; Map.Entry&lt;String, Integer&gt; entry = entrySetIt.next(); System.out.println(entry.getKey() + \"--\" + entry.getValue());&#125; 直接遍历Map.entrySet集合（容量大时，使用此方法） 123for(Entry&lt;String, Integer&gt; entry : treeMap.entrySet())&#123; System.out.println(entry.getKey() + \"--\" + entry.getValue());&#125;","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"-Collection框架","slug":"Collection框架","permalink":"http://yoursite.com/tags/Collection%E6%A1%86%E6%9E%B6/"}]},{"title":"深度学习入门","slug":"神经网络入门","date":"2020-01-16T08:49:19.000Z","updated":"2020-01-26T09:38:08.469Z","comments":true,"path":"2020/01/16/神经网络入门/","link":"","permalink":"http://yoursite.com/2020/01/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8/","excerpt":"前言 深度学习之神经网络结构，梯度下降算法，及反向传播。","text":"前言 深度学习之神经网络结构，梯度下降算法，及反向传播。 神经网络和多元一次函数的联系 我认为多元一次函数就是一种神经网络。神经网络中：输入层-&gt;处理层-&gt;输出层，就相当于多元一次函数中：多个变量x经过函数得到结果y。 神经网络中的可训练参数权重，偏置值 梯度下降的优势 应该是简化了计算吧。最小二乘法就是直接求多元函数极值，求偏导，让偏导为零，解方程组，当变量有非常多个元素时，其计算量就变得非常大了，梯度下降法可以看作是解该方程组的简化，它只需要一个反复迭代的式子，沿着梯度下降，就可以求出其极值。 疑惑 神经网络训练就是对权重和偏执值进行调整，直到到达一个最优结果，那么最初的权重和偏执值如何设定，都从零开始？ 看了很多遍视频，还是看不懂，所以也没啥疑惑，只有不懂。。。 比如如何微调参数，梯度方向如何确定等","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"-神经网络","slug":"神经网络","permalink":"http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}]}]}